From f3e14d0bed237b1f0e274be62f83b0f27e4d2486 Mon Sep 17 00:00:00 2001
From: Scott James Remnant <scott@ubuntu.com>
Date: Tue, 5 Nov 2024 11:01:52 +0100
Subject: [PATCH] trace: add trace events for open(), exec() and uselib()

This patch uses TRACE_EVENT to add tracepoints for the open(),
exec() and uselib() syscalls so that ureadahead can cheaply trace
the boot sequence to determine what to read to speed up the next.

It's not upstream because it will need to be rebased onto the syscall
trace events whenever that gets merged, and is a stop-gap.
---
 fs/exec.c                 |  7 ++++
 fs/open.c                 |  4 +++
 include/trace/events/fs.h | 71 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 82 insertions(+)
 create mode 100644 include/trace/events/fs.h

diff --git a/fs/exec.c b/fs/exec.c
index 7d424337b4ec..04528b14bbab 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -71,6 +71,7 @@
 #include <asm/tlb.h>
 
 #include <trace/events/task.h>
+#include <trace/events/fs.h>
 #include "internal.h"
 
 #include <trace/events/sched.h>
@@ -153,6 +154,10 @@ SYSCALL_DEFINE1(uselib, const char __user *, library)
 
 	fsnotify_open(file);
 
+	tmp = getname(library);
+	trace_uselib(tmp);
+	putname(library);
+
 	error = -ENOEXEC;
 
 	read_lock(&binfmt_lock);
@@ -929,6 +934,8 @@ static struct file *do_open_execat(int fd, struct filename *name, int flags)
 			 path_noexec(&file->f_path)))
 		goto exit;
 
+	trace_open_exec(name->name);
+
 	err = deny_write_access(file);
 	if (err)
 		goto exit;
diff --git a/fs/open.c b/fs/open.c
index 1ba1d2ab2ef0..dac0aa7362da 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -34,6 +34,9 @@
 #include <linux/compat.h>
 #include <linux/mnt_idmapping.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/fs.h>
+
 #include "internal.h"
 
 int do_truncate(struct user_namespace *mnt_userns, struct dentry *dentry,
@@ -1218,6 +1221,7 @@ static long do_sys_openat2(int dfd, const char __user *filename,
 		} else {
 			fsnotify_open(f);
 			fd_install(fd, f);
+			trace_do_sys_open(tmp->name, how->flags, how->mode);
 		}
 	}
 	putname(tmp);
diff --git a/include/trace/events/fs.h b/include/trace/events/fs.h
new file mode 100644
index 000000000000..e967c5568db4
--- /dev/null
+++ b/include/trace/events/fs.h
@@ -0,0 +1,71 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM fs
+
+#if !defined(_TRACE_FS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_FS_H
+
+#include <linux/fs.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(do_sys_open,
+
+	TP_PROTO(char *filename, int flags, int mode),
+
+	TP_ARGS(filename, flags, mode),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+		__field(	int, flags			)
+		__field(	int, mode			)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+		__entry->flags = flags;
+		__entry->mode = mode;
+	),
+
+	TP_printk("\"%s\" %x %o",
+		  __get_str(filename), __entry->flags, __entry->mode)
+);
+
+TRACE_EVENT(uselib,
+
+	TP_PROTO(char *filename),
+
+	TP_ARGS(filename),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+	),
+
+	TP_printk("\"%s\"",
+		  __get_str(filename))
+);
+
+TRACE_EVENT(open_exec,
+
+	TP_PROTO(char *filename),
+
+	TP_ARGS(filename),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+	),
+
+	TP_printk("\"%s\"",
+		  __get_str(filename))
+);
+
+#endif /* _TRACE_FS_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
